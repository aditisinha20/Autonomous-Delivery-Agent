# -*- coding: utf-8 -*-
"""src/simulator.py.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Mj_sOZXDssJY6GG7X4MX5AFhOV2NJorL
"""

# src/simulator.py

import argparse
import json
import time
from environment import GridEnvironment
from agent import Agent
from search_algorithms import astar, ucs, bfs
from local_search import hill_climb_local
from pathlib import Path

def load_dynamic_obstacles(json_path):
    with open(json_path, 'r') as f:
        data = json.load(f)
    return data['obstacles'], data.get('start_time', 0), data.get('timestep_seconds', 1)

def get_obstacle_positions(obstacles, t):
    pos = set()
    for ob in obstacles:
        trajectory = ob['trajectory']
        if t < len(trajectory):
            pos.add(tuple(trajectory[t]))
    return pos

def run_simulator(mapfile, obstacle_file, algo, start, goal, output_file):
    env = GridEnvironment(grid_file=mapfile)
    obstacles, start_time, timestep = load_dynamic_obstacles(obstacle_file)

    planner_fn = {
        "bfs": bfs,
        "ucs": ucs,
        "astar": astar,
        "hill": hill_climb_local
    }[algo]

    agent = Agent(env, start, goal)
    t = 0
    log = []

    def plan(current_pos):
        path, cost, nodes = planner_fn(env, current_pos, goal)
        return path, cost, nodes

    path, cost, nodes = plan(start)
    agent.set_path(path, cost)
    log.append({
        "time": t,
        "event": "initial_plan",
        "path": path,
        "cost": cost,
        "nodes": nodes
    })

    i = 1
    while i < len(agent.path):
        next_pos = agent.path[i]
        obs_pos = get_obstacle_positions(obstacles, t)
        if next_pos in obs_pos:
            log.append({
                "time": t,
                "event": "replan",
                "blocked_at": next_pos,
                "prev_path": agent.path[i:]
            })
            path, cost, nodes = plan(agent.path[i - 1])
            if path is None:
                log.append({
                    "time": t,
                    "event": "failed_replan",
                    "from": agent.path[i - 1]
                })
                break
            agent.set_path(agent.path[:i] + path[1:], cost)
            log[-1]['new_path'] = path
            log[-1]['new_cost'] = cost
            log[-1]['nodes'] = nodes
        t += 1
        i += 1
        time.sleep(0.05)  # fast-forward simulation (optional)

    Path(output_file).parent.mkdir(parents=True, exist_ok=True)
    with open(output_file, 'w') as f:
        json.dump(log, f, indent=2)
    print(f"Simulation complete. Log saved to {output_file}")

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument('--map', required=True)
    parser.add_argument('--obstacles', required=True)
    parser.add_argument('--algo', required=True, choices=["bfs", "ucs", "astar", "hill"])
    parser.add_argument('--start', nargs=2, type=int, default=[0, 0])
    parser.add_argument('--goal', nargs=2, type=int, default=[9, 9])
    parser.add_argument('--out', default="../results/logs/sim_log.json")
    args = parser.parse_args()

    run_simulator(args.map, args.obstacles, args.algo, tuple(args.start), tuple(args.goal), args.out)

