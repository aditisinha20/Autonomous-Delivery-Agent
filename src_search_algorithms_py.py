# -*- coding: utf-8 -*-
"""src/search_algorithms.py.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qkMeODGYgbCfvgEv7WYJ6HOYk3tUJVKG
"""

# src/search_algorithms.py
from collections import deque
import heapq

def reconstruct_path(came_from, end):
    path = []
    cur = end
    while cur is not None:
        path.append(cur)
        cur = came_from.get(cur, None)
    return list(reversed(path))

def bfs(env, start, goal):
    frontier = deque([start])
    came_from = {start: None}
    nodes = 0
    while frontier:
        cur = frontier.popleft()
        nodes += 1
        if cur == goal:
            path = reconstruct_path(came_from, goal)
            cost = sum(env.get_cost(p) for p in path[1:])
            return path, cost, nodes
        for n in env.neighbors(cur):
            if n not in came_from:
                came_from[n] = cur
                frontier.append(n)
    return None, float('inf'), nodes

def ucs(env, start, goal):
    frontier = []
    heapq.heappush(frontier, (0, start))
    cost_so_far = {start: 0}
    came_from = {start: None}
    nodes = 0
    while frontier:
        g, cur = heapq.heappop(frontier)
        nodes += 1
        if cur == goal:
            path = reconstruct_path(came_from, goal)
            return path, g, nodes
        for n in env.neighbors(cur):
            new_cost = g + env.get_cost(n)
            if n not in cost_so_far or new_cost < cost_so_far[n]:
                cost_so_far[n] = new_cost
                came_from[n] = cur
                heapq.heappush(frontier, (new_cost, n))
    return None, float('inf'), nodes

def manhattan(a,b):
    return abs(a[0]-b[0]) + abs(a[1]-b[1])

def astar(env, start, goal):
    frontier = []
    g_score = {start: 0}
    f_score = {start: manhattan(start, goal)}
    heapq.heappush(frontier, (f_score[start], start))
    came_from = {start: None}
    nodes = 0
    while frontier:
        f, cur = heapq.heappop(frontier)
        nodes += 1
        if cur == goal:
            path = reconstruct_path(came_from, goal)
            return path, g_score[cur], nodes
        for n in env.neighbors(cur):
            tentative_g = g_score[cur] + env.get_cost(n)
            if n not in g_score or tentative_g < g_score[n]:
                g_score[n] = tentative_g
                f_n = tentative_g + manhattan(n, goal)
                f_score[n] = f_n
                came_from[n] = cur
                heapq.heappush(frontier, (f_n, n))
    return None, float('inf'), nodes